00:00:02       Good. All right, good to go. OK. So let's jump in and let's talk more about, uh, well let's, let's introduce a couple of things and then try to figure out the best flow for this afternoon. Seems like flatten is tending to be one of those stretch problems that I'm going to come. I'll come back to, um, in the last fifteen minutes or so of this afternoon's lecture. How does that sound? Good guys. Good with the flatten. That's one of those that's very common interview question because it exposes some really, uh, important concepts, uh, one of them being recursion and uh, so we'll talk about recursion introduced it to you right away. OK, let's talk about closure. Let's talk about this, um, limit function called count. OK. So a couple of you were sort of a dinking around with that. I'm trying to get some help with it and that's great. That's awesome. It's, it's really, um, you have all the right tools for this one, but putting them together in the right sequence in the right order and understanding how to use the tools is a big, is, is definitely a big Gotcha. 

00:01:23       It's big, like, like what can I say here? It's like, it's hard to go from point a to point b when there's actually like an, a [inaudible] [inaudible]. So, um, what, what I'm getting at here is that I've given you a few tools to get this one solved, but putting it all together is a little tricky. So, um, let's, let's talk about what the tests do and how they're running it. Well, first off, um, it's expecting that we're returning some sort of functioned from within this function calls, so when we call limit function called count, we're going to return to function, um, that will be invoked on its return. So when we, when we call it from here, it said, expect that, you know, this call. So the output of this function to be a call of another function. So that's what we mean by return a function rather than I'm going to pull down and pull down my other chat and just one second, one second, going to pull out the, uh, the zoom chat in case anybody tries to reach me there. 

00:02:43       But on my desktop, I had a chat, a personal message chat, and I don't want you guys to be exposed into my world of fantasy football. It's, it's, it's dark world's OK. Um, so, OK, so that's what we're expecting this. We're expecting to have some sort of, you know, returned function that we'd call, so call to her return function. So, um, if I, W if I were going back to closure, OK, so if I look at this, we know that we returned functions should only allow, OK? So should return a function that invokes callback. So, um, if we go ahead and just do that real quick return are anonymous misfunction and it's just going to invoke callback. We ought to you passing a test, maybe it may need other stuff, but what I'm reading the tests and how they're expected to be run. Awesome. So we're returning a function call. 

00:03:35       Our function itself returns a call to another function. OK? All right. So that's our first test there. But let's look at what we're failing with our other tests saying expected value. Uh, let's see. So, oh, so this is the limit of function called count. OK. So yeah, there we go. Expected value using triple equals, true to be undefined. So we're not really doing anything, um, with undefined. So if we look at that next test, um, this, this is what we were getting out of this. So if we pass in, true, we're expecting true to be, you know, to have come back. So let's look at how all of these runs that living function called count our function that we're passing to. It is this function and we we're giving it a limit through saying, hey, there are only two times that we can invoke this callback that gets run. 

00:04:23       And so that's how this function a runs. We take a call back in a number of times and we say we can only return that call back and number of times. So if we look at this, this first one, I'm expected limited function to be true on that first, that first call cause we invoked it here and then we invoke it again and we invoke it a third time. And it's no. So it's no because of why, why would we expect no on the third time? What's our function limit? What's our callback in vocation limit? How many times can food be called to? 

00:05:06       So this could have been false defined, whatever, but we gave you the specific value type of no and no is just is just equal to know. OK? So that being said, um, we need some sort of conditioned within our, our limit here. So we need to say are conditions should be something to this to the extent of his watch for [inaudible] UK if an equals some sort of like trigger. So like it's a once, once in is called, um, x amount of times. So once and is called an amount of times. I'm once CB I should say what CBI is called n amount of times, fraternal. OK? Else we want to invoke CB. OK. And, uh, keep track of that. Keep track of that. How many times so and increment our counter that we haven't defined yet. 

00:06:36       OK, this is our algorithm, right? We needed, we need calendar in here. Very, very similar to this. It can look just like this in some respects, some sort of counter, very similar to this to some sort of counter that allows us to keep track of how many times callback has been invoked. All right, so if we're going to make our, our base case, and that's maybe a new word for some of you, um, once, as our base case is we're eternal when callback has been called as you know, as many times as a right. And we keep track of that with this counter. OK? So we have a base case to set up here because we do not want to invoke callback if n equals counter, right? So let's define our counter. 

00:07:28       So the first time we wanted to be set to zero because the first time it hasn't been a vote, so incremental and return that that value out. OK, OK. So here, here is your algorithm work. If this is our base case, right? So it's a combination of watch for an and you know this line right here. So if n is the same as our account, we need to return. What does the test looking for know? Awesome. And then how do you keep track of this? So we just hit this case. We can do this all on one line. We just hit this case where it returns. No, because at the same. Otherwise we're just going to run into and I can just bring this up one line. So it's all right there. That's our algorithm there. That's, you don't need a curly braces in your if statements, if it's just a single line that you're returning. So Fyi, this is, this is completely valid. Uh, it's a little bit harder to read because it to go, it's not like block by block, but like it's, it's really just, it's the same thing is doing this and breaking the line like that. 

00:08:49       We don't care to do that at this point. And then this turned to cost, which you shouldn't give. Do we keep track of this? Whatever we have that helps us keep track of how many times call back has been invoked. Yeah, it's like a memo, but it really is just our account, right? That's all we need to worry about to increment our counter. So that's our next point here. Increment our counter, we're going to invoke callback and what we're going to do is we want to actually have this function, needs to return the invocation to call back, and then we're just going to say, call a counter plus plus, because in this case, the next time we get there, it'll have been called once the previously little increment and it will allow us to call it any more than those times given. OK? So let's actually run a test and let's see what happens. 

00:09:48       OK, so we returned a function, rap version of the original function that can only be invoked and the amount of times. So we look at our tests were actually satisfying this condition. However, there's another condition we want, um, to be able to send up some arguments and keep track of those arguments. OK? So this is where the combination of a few different practices comes into hand. OK? Um, the arguments that get fed into, um, into this callback can loop back through our callback function and we can pull them off at that argument. Spread operator, OK, that arguments respirator. So if I want to take these arguments and then reuse them and then pass them up through the callback chain, so every time this function gets invoked to keep, you know, keep advantage of, of this type of thing here, if I call limited function called count with a bunch of arguments, right? 

00:10:55       So our limited function is now set to limit function called count or we're passing this original foo function here and food is going to take five, ten and 15 and presumably add those things together, right? Because that's what. That's what we're going to be able to do here. We're going to be able to call it and it's going to be able to do. It's going to be able to operate and return what comes out of here because when we return this call back, we're gonna be able to keep track of those arguments that come through. So how do we do this? How do I actually keep track of these arguments? That's the biggest problem here with this, with this as the biggest Gotcha on this is that now our callback actually has some arguments being fed or some some parameters being fed in some arguments eventually later, so what do I need to do here? Yeah, and save it to a very well, how can I do that? What did we learn earlier today that allow us to save those arguments to some sort of variable? We don't care how many arguments there are arcs, right? Just saying, hey, however many artists come through here, throw them into our returned function are right, and if we're spread operating those we can not let us see what comes out of arps. 

00:12:11       A let's. We actually need to run the function this time around the test to OK, let's see what happens. OK, check it out while we invoke this function for different times and we've returned the invocation to that and now one of them, we get this array of functions or of parameters, arguments. Now what happens if we actually spread those out again? Well, let's find out. Let's see what happens. Check it out. If I use the spread operator after having used the respirator, when you have to have to use it with the rest ramps, I actually get the values that are in that object or array in this case so I can simply pass those arguments back to our function and it's going to be able to keep track of them through, just give you a lot to keep track of them through that closure and call that chain. 

00:13:19       Very, very deep level stuff here. This is not, this is not something you would learn, you know, this is not something you would normally learn in a bootcamp or like an online immersive school like this. We have the ability to go deep into these concepts. OK? Just show you more and more about them. So yes. Anything. OK? So let's look at the spread operator and let's look at what it actually does. Oh, cool. We have all our stuff from earlier. OK. So if I have an object, a, OK, we're just going to say it's my object again. So the classic Ryan Age thirty one occupation, um, we'll call it vs code event. That's really ninety percent of my job description going. OK, let's look at what this respirators in the spread operator can do for us. Let's say that we want to just extrapolate these, these properties as their own variables. Well, one thing we could do is we can say, hey, in this object, I want name and age and occupation from my object. OK, let me make sure. OK, whoops. 

00:15:07       Yeah. Um, yeah, 

00:15:18       it doesn't like something. 

00:15:21       OK. 

00:15:23       Do you see this real quick name? I have a typo with occupation. OK. Those were the same. Very, very much the case. OK. All right. So check it out. I have, what am I doing here? I'm actually cataloging variables, right? So I've used this idea that, um, that there can be, you know, that we can actually extrapolate the variables, the property names as variables from within an object. This is saying, Hey, create a name variable and age variable and occupation variable, but find those variables that exist on a, on this object. If I tried to put something like a birth date, it's gonna, it's gonna Choke. It's not gonna, it's not gonna. Give me anything there. I'm, and this, let's see what birthday is. Well, it's not going to choke. It's just going to give me an undefined value. I believe that doesn't exist, right? It's not that. It's not defined. It's data is undefined. What's the difference? What's the difference between not to find and define? 

00:16:53       Wouldn't that Rhonda for some reason and was less than count. So hypothetically, count starts at ten and is five and would never equal count. Well the hope is that by the time you call your function the first time. So yeah, that would ruin art. That would ruin our call. Right? So what would you do to fix that? Well, um, you would say something to the effect that if n is less than count or if, if while n is greater than count or whatever, it could be your logic. So yeah, this is just simply saying whatever. So I'm not the fine is not a variable. Undefined is. Yep. So not defined means that thing doesn't exist. So if I tried to come in here and say something like, hair color, hair color is not defined. Birthdate is defined because we're trying to define it here, but we're just not assigning it. Anything has nothing that it's attached to. Variable exists, but it doesn't, it's not, it's not. And there's no data associated with birth date. I wanted to, I could add birthdate to this object and we would satisfy this condition here, but right now it is completely undefined. OK. What if I didn't know anything about the subject though? Um, let's play around with this. Let's look and see what the, what the spread operator does for us here. And let's call this food. 

00:18:23       OK? 

00:18:27       Hmm. Interesting thought here. Doesn't quite work the way that it would work with functions calender to demonstrate this. It just doesn't really quite give us what we need. So I'm going to point us all over to the spread operator documentations. I'll actually just, I'll just add a spread operator and um, I'll let you got coast called spread syntax now from, from within the, uh, the, uh, if you look at the docs, I'll post these in for you. But yeah, I just wanted to let you know that you can structure an object this way as well, so you can take this out and you can say, Hey, I want name, age and occupation from within this object. Right. And you can save and, and hold those in as variables. Don't screw with me and you know, you can come in here and say I want to know. Well, let me just say this and our original object is on the, it just creates new instruments, properties that's not going to work for me either. So I don't want to move too far into that is kind of just a sidetrack thing where I was, where I was getting out with structuring an object and then using that spread operator to grab those, those original values pass to function, you know, or you could, you know, there's so many different ways you can use this stuff. So you're saying the spread operator, like for some reason is not loving my job. OK, 

00:21:28       OK. 

00:21:29       So I've in, in uh, this sort of environment, I've done this all the time with like react where I have, you know, like one property that comes down, another one and then I want to just pass, you know, all of the rest of the properties to it. Um, and so I'd do structured the whole thing like this, but I believe that there's some sort of environmental like we need. Yeah. So there's a different context of the way that I've defined my coat here. 

00:22:05       We'll definitely, um, we'll definitely touch a lot more on this stuff later. Yeah. If any of y'all have a can can figure out what I'm trying to do here and you know, maybe get, let me know if you. Awesome. Cool. I didn't want to waste too much time with that, but I did. Um, so that is my fault. So I wanted to get into cash function, but I wanted to get into that flattened function first because it exposes what I want to talk about next. But yeah, this right here is um, so yeah, there is a limitation to this and troy definitely brought it up. Um, but this would work in terms of how we're testing and operating on the code. So, um, it would still work if you're trying to, it would still work for intents and purposes of reusability if you were trying to pass this, some sort of callback, you know, keep track of the arguments that come through that call back, um, you know, structure men and DC, so respiratory, those arguments, um, throw them on that, that a spread operator and then turn them back into the arguments themselves. So, so let's try to mimic down here, but. Oh Wow. Shame on me for not coming with a full example of that. I should have been a better examples before trying to come up with one on the spot. Questions about that, about, I guess this would be really hard to come up with questions on how it's all, you know, continuously operating. Um, there's a lot of stuff going on here, Jay, that does anyone have any specific questions about it? Does anyone need anything clarified on it? It's not necessarily how it's expected to be, um, um, salt, but it's one way you could have solved it for sure. Troy asked about the two return lines. Well, what are we returning when we return? So what does this return actually returning? And Pfizer asked, where's the close? You're actually happening. So closures happening callback with ours. It's also happening over counselors. There's a closure there as well. OK? 

00:24:54       The return is everything inside the currently brackets, right? 

00:24:59       So yes, we'll. OK. So which returned? So let's call this return one and returned to. 

00:25:04       Yeah, she'll return. One has everything inside the, the curly brackets at the end of line twenty three down to [inaudible], 

00:25:12       right? Well, what we're returning is a function call. So when I ride a function like this with some sort of inner function, what this grief function is doing is returning the call to inter function. So we re, we opened this up and we say, hey, invoke great functions. So call this function and it's going to go. And it's to do this compilation and everything and it knows that will after it's being invoked, we're going to return out of it a function call, which is actually doing our console law and technically we could do something like this or not. I already ed counselor, so I could return our agreed stream. And then console log [inaudible], just not the fund of course. And then we need a console log that result whenever it gets returned out of that function. That makes sense. So I'm returning a function that has its own return. There's two returns there. So the first time that we call return on this limit function called count, it's invoking another function. It's calling, the return itself is calling another function, which then goes and does his logic and it says, hey, check to see if an equals count. If it doesn't, then return. No. So that's our end. It will. That'll 

00:26:44       be the base case. It's never going to. It's never going to invoke call back if it gets to this line. Otherwise increment the count and return the callback. But we keep. Keep a track of the arguments that get passed in. 

00:27:00       It's not necessarily iterating grant. Um, let's see. So let me make sure that I get caught up either the coverage, depending on the criteria. Yes. So we get three different types of returns. One or the other. You're right. K first returning folks. The inner function returned to returns the results yet. So that's an returns this and then so who wouldn't? So wouldn't both returns be referring to call arguments? Um, in a way yes. Because what are we returning? Yes. So essentially, yes, because we're, we're, we're calling the invocation of this function and allowing it to do its thing right? And this function returns this. So if this returns simply just returns an invocation to dysfunction, which is that first test. So type of closure methods, um, limit function called count invoked, whatever comes out of that invocation should be a function. That's the first test here. So this, when we invoke this calls, this function, and then we come through it and we increment the count and we returned the call back, which this gets returned out of this function. So once we invoke this function, this return comes or this return comes based on this condition 

00:28:22       and there is no iteration in this point. We're not necessarily iterating because we're only just as simply invoking a function that invokes a function and is being defined in the testes and is two and then three in this case. And if you were to think about this like recursively sort of in that iterative fashion that you're trying to, trying to piece this together with, um, it's like we have, it's like we have a base case, like it's not really, it's just a conditional right? So we're only going to be able to run this function as many times as an equals count. OK. 

00:29:07       Yeah. It's good stuff. It's really fun for me to break this stuff down because it helps me, like really just hold onto it. And the more times that I can repeat it, a different way of saying things, the better off some people could get it. Like, oh, that makes sense when maybe this whole time things weren't making sense. OK. Any other, any other questions about limited function called count? This is not trivial stuff, guys. This is not javascript [inaudible], right? This is, this is profoundly. I'm exposing you to parts of the language that a lot of people just don't, don't know. 

00:29:43       Not necessarily don't know, but parts of the language that people just don't. I'm getting exposure to in their day to day, but stuff that's really important to understand for sure. All right. How are we doing? 

00:30:07       OK. 

00:30:07       Did anyone solve this in any different way? I'm sure there's, there's dozens of ways to solve this if I can get through. Flatten fast enough? 

00:30:32       Yeah. Yeah, yeah. 

00:30:48       Yeah. So let's just go over our notes one more time real fast because that's a really good thing to understand. OK. Um, let's go back. Start. Um, cool. Oh wait, don't we have? Nope. OK, cool. So let's say a cost, um, knew my function and we can go over this afternoon. I'm totally fine with that. 

00:31:12       OK? Yeah. 

00:31:38       Yeah. Linter who loves the winter by now, winters are the bane of a lot of people's existence. OK, so check us out here. We have a bunch of arguments that we've thrown into this, a function. Now all we've done here is just set us up to, you know, receive a, you know, a bunch of arguments. We've, you know, if I was to just call like this, it wouldn't really keep track of that stuff for us. Or if I were to say argue arguments, is that, um, it's, it's really not. Let's see. Our. Yeah, so rex is special like parameter and check it out, check out, check out what comes out of this. It's, how can I explain our best? It's, it's an object, but it's an array is an array like object almost like each one of these things that we pass to our 

00:32:40       gets built on this object. OK? This is how javascript is taking this stuff. And it's saying that if the, if the first thing from this function is defined, then we want it. We want to know about it. So like I said, if the first thing here x and we just constantly log x, then what we get out of the x is this, this beautiful first argumentK.  is first thing that's passed to here and now javascript is just storing these two, three and four and five on that object. OK, do A. Yeah, I use the keyword here. So if you look at what's actually getting, getting stored here saying we have zero that we have one, two, three and four and all this stuff is just like breasted on this object. So if we want to get at those arguments, we could simply just you structure and now we get a beautiful array of the arguments as opposed to that giant object with all that crap assigned to it. So. And then if I take this and I just say, Hey, I want to just take it a step further and destructure that array. I totally can. Within this context. 

00:34:06       My presumption is that this actually has to happen within an object or function context, which is why I couldn't get a good example of it to you guys earlier. But it's, it's not, it's not smart to assume all the time. So I hope this defies arms a little bit. I pulled off and if I want to look at them, I can use this keyword of arguments right now are going to be the first parameter, but if I use this key word arguments, I can see the arguments object, the big giant object that comes through this, this function and structure that objects on the rest parameter. 

00:34:52       I can just grab everything that comes out of it. So these are just little tricks, little shorthand tricks used to have to like for bar 10 objects, Marquis and arguments. OK, cool. Glad I can clarify just a bit. That's good. It's good to understand this stuff for sure. But it's not easy. It's not trivial stuff. OK. So find, um, find this pretty interesting filter is pretty much like fine, but it's going to be a ray of all the stuff that you filter out. Um, but I wanted to get through this stretch problem because it's something you commonly will see in javascript interview question. I don't think I've ever been asked it. Um, but I know that a couple, a couple of instructors here have, um, in interviews. So essentially what we want to be able to do is just send in a multi-dimensional array. Ryan, what does multi-dimensional array mean? Well, that's an array with arrays nested in it. So we have our, my r equals, sorry, I can tell. It's a afternoon. 

00:35:57       Yeah. 

00:35:58       OK. So we have one, two, three, and then we have four 

00:36:03       nested 

00:36:05       and then we call flatten with our. 

00:36:17       Cool. 

00:36:20       Now what we want to return out of this, we want this to yield out a or an array, a new array. One, two, three, and four. 

00:36:35       OK. So where did you do this? We need to know a couple of things. And you, once again, this is one of those where you have all of the tools, you just maybe have not seen a recursion yet. So this is brand new to some of you. It's like this was actually pretty trivial. So we need a check for every single index that we look at. If that index is either in a rare knocked, if it isn't a re, we need to handle it in a certain way. Um, in fact this should be my test cases is what the biggest DPS, so I look too deep and it's just like, hey, you just have so many nested objects or array array is an object, right? So on our first iteration, one is not going to be an array, so it would be a candidate to be, um, essentially added to our output array and returned out of it. So first thing we're going to need from this is some sort of outlet. So we're just going to say constant output equals array of elements. Just an array. It's going to be your elements, sorry. And then we need to be able to look into every single look at every single element and check to see if it's an array or not. If it's not an array, then we're going to push it into this outfit or Ray. And then this is going to be our output. 

00:37:50       Yeah. 

00:37:53       So right now calling this function, I just simply gets 

00:37:57       and output. 

00:38:01       It should be an invoking. Oh, I needed a console dot log when it's your turn. Any that execute it with nifty 50. So right now it's just a, an array similar 

00:38:15       Mt. 

00:38:16       so what can I use to iterate over this list of elements? I mean we could use a native for loop here, but what's another handy function that I have at my disposal at this sport? Exactly. So I can use our beautiful each phone. Whoa. All caps. I'm going to scream each. I can use our each function and pass it. The elements that get handed in. Now I'm getting an error because I have no function here. Hey, let's check it out. Let's rush. I didn't mean to do that. I'm sorry. OK. So for every single item in this array, for every single number, let's just call it a number because we know it's in a random numbers. Um, we're going to be able to look at that. OK? So let's say console dot log on. 

00:39:10       So check it out. Now we have gone one level deep into our, um, given elements array because look, we are at least, sorry, just this deep. Hey, we are one level into our multi dimensional right now. And every single index is going to be one or nested two or nested three and four, which has invested array instead of four instead of that. So we are, we are incepted here is total inception, so four is not, is not unblocked. It's, it's, it's blocked out. OK. So we're actually going to use a technique called recursion to be able to solve this problem. So our check is to figure out whether this element that we're looking at the number is actually a number or a re. OK. So if, if the first pass, it's one, we're not going to hit that check, then we're going to push it into this array. Right? So how do I in Javascript, how do I check if something isn't a array? Yes. So I can say something to the effect of if capital array.is array and then pass it our. No. OK. Let's see what happens inside this conditional 

00:40:35       look at that. 

00:40:42       All right. We've already gone to a point where we, we have separated out the, the um, the numbers and the erase. We're in this conditional where if one thing gets re otherwise it's just not an right otherwise it's a number and we were where we are and it's important for us to have that number value. What do we want to do if we hit this else condition? Sorry, I said that pretty terribly. Once we hit this Alec's condition, what is our. What is our stop? What is our stock? What is the thing that we need to do at this point? If our code says that are numb is actually a number of non array, what do we do with it? We push it into our output, right? So we're going to say output 

00:41:36       dot push. No, look, we're already getting that. Logic actually works. So now we need to do something here and this is where recruiting kicks in. This is where things get really fun and javascripts well in programming in general, and remember the definition of recursion is we have a function that calls itself until it stops. So you need a program at a stop or stop is this. We're going to iterate for every single element in this, in this call, when we call flattened, it's gonna, iterate over the list of elements that we're giving it. So if we call flat and again, we're going to expect to give it a bunch of elements so all we simply do, um, if, yeah, if you wanted to, you could simply try and just do, flatten and pass it. So we're work limits. We're calling flatten from within flint, OK, and pass it the numb at this point because it's an a right now we have some inherent problems here. 

00:42:34       Will, number one, we need to actually hold onto the value that gets, you know, gets called into that next function call because we're going to use this to build a call stack. But this is our algorithm here in a sense that once we get to this point, we're just going to make a call to flatten, but we need to first do something with that. And then we're actually going to change on, um, the aggregation of that information found in that array as well. And there's a really cool array method that y'all could've used to do this, and it's kept in cat was not off the table. Um, you can use concat, Polish, pop, et Cetera. Do not use the exact method of you're replicating. So we don't want you to use it for each to replicate each a map and using, reusing each over and over again, helps you understand this idea of functional programming. OK? So you can actually use concat here. OK. So let's try. What I'm OK. Kaylin tried to use, reduce. Nice. I'm in the return that call. Heck yeah. A mighty fine function there. 

00:44:06       I can tell you exactly how it works. You have the same exact logic than I have, but first need to finish my function here. So what I'm going to do actually do is I'm going to have some sort of, you know, um, I, I get to basically allowed this output function to become the concatenation of what happens after I call the flattened with the new value. So I'm going to say now our output becomes our output dot concat. Hopefully that does what I want it to. All your changes to let me do that. Hey, that is awesome that it worked right here. You can see I'm actually flattening. So what am I actually doing here? Well, I have an array and I'm reassigning the value of that array k, so whatever exists in this re array, OK, at the point that I'm actually reassigning, it is a reassignment of the, the concatenation method, which if you take the time and look up concat, it'll help you with so many different things in your entire career. I love can cad. It means concatenate basically items into an array or. So they read our prototype that and cap method right here are the Indian documentation for it. 

00:45:38       OK. 

00:45:44       Basically we get, you know, I could have essentially said, you know, I could've created a valuable here, value variable here and then, and then restart it. But I felt like because I wasn't meditating the original given array, I'm, I'm fine to just reassign a variable that I've declared within my inner scope. So this is a valid, um, operation with this function. So now let's try and actually achieve a flattened affect with the reduced function. Actually, no, I wanted to go back into, um, I wanted to go back into um, OK. A Grove was asked, what is numb? Is it an array? Well, yes, if you hit this line, it is because nothing will be each index found. So the second time we iterate, we actually get an array. In fact, let's actually take this. Let's go to a cool tool called hi found tutor. OK, 

00:46:57       nice. 

00:47:14       Three. 

00:47:19       OK, 

00:47:20       yeah, welcome to the wonderful 

00:47:30       world of python tutor chat. One second saying there's only four steps. There's an air. Oh, each is not defined derp. I'm find it. That's why there's only four steps is going to get real busy because it's going to call each as well. OK? So ninety steps to complete this problem before it. OK? So defining each, it's going to create each and it's fraying or going to be able to use it. And then our function call to flatten. This is where everything gets started here. So what is our original input? Elements originally is an array with index of zero, of, of, of just the number one than index out. What is an array with index is zero number two, and then two is an array where index zero is three index and one is an array where index at zero is an array where index at zero is. Wow, that's a mouthful. 

00:48:49       That's hard to think about. And talk about the same time. Let me just increment that can bump it up for you. So this is really cool to x to show how your code is being executed. So now OK defined output, that's going to be our array that we, we ended up. And now here we go. We're going to actually call each, so we're calling each and it's going to go and do things to iterate over this list. So here comes our callback. That callback that we're passing to each is this recursive callback here. So it's going to get real tricky. Just second hands are going to be. All hands are going to be on deck here. So callback block one is still zero in block two is to k, so output. OK? So here we go. Here was, here's where we're in, we're into our callback function. 

00:49:33       OK? So we just saw that online [inaudible] our first element, which was the number, the number was one. Our first element was actually a member. So we actually hit that line 13 instead of 11. OK, so our condition is working. If this thing, this number at this index that this number here is actually an array, then run this line, otherwise run this line. That's our base case right here. And so now we can execute again and return value coming out of that is nothing. OK? So now we go back into our iterator. So each is our iterator function. And then we're going to, we're going to take the next element that comes out of our array, which is going to be an array of at have one index, one value, OK? So it's going to be rated with the number two nested into it. So we're going to move forward and it's gonna bounce down to this check here. Now are we going to hit line 11 and line 12 at this point? We'll look at them, look at what number, what the second index is, what is it? It's an array. So which line are we actually going to execute? If it's an array, what line are we going to execute in the code next? Right? So we're going to take that, the output where it's at j, and we're going to say output currently isn't a with one value in it. Now we're gonna say output dot concat. So combine the flattened version of that array into this new output. OK, now we have a recursive call that needs to step through everything. And so what is, what is the value going to be this next time? So right now, look at what number is in the stack frames. So what are we going to do with it? What's going to happen? Which line is going to trigger at this point? Numb is not the number two. It's no longer just an array like it was up here. It's going to go to line 13, right? Presumably? 

00:51:52       Yeah, 

00:51:54       boom. Now our output or should have, well we don't see that yet. Will see it will see it the next time we iterate. Now we're getting into our, our function again because we still need to iterate for that first iteration. OK? Now moving into it. Awesome output should have. OK, now we got to our third, our third, um, so index at two is what we were looking at. So right now we are going to do the same thing. Now we need to. This is going to actually have two iterations for it at minimum, and we just keep on going. We need to keep track of what numb is pointing to right now. What is non point two? It's pointing to a big array. OK? This right here is this array that nested value. So we need to actually concat and recurse. Now on this line, we're going to go to 13, right? And push through into our output array. OK? Moving back to our original iteration and what are we at right now? Now we're looking. Look at what number is known as what? It's an array where it's first index is an array where it's first indexes for. Keep on moving. Holy Cow. All right, so now let's get back to that. Point it back to the conditional Jay, now what is known pointing to its pointing to our very last message at array and we're going to concatenate and, and flatten some more. So recall that recursive function finally. 

00:54:05       Yeah. 

00:54:07       No, it's going to take all or sorry. Finally, this function is going to take everything that we've sort of stored in this memory chain and then it's going to add it to our final output array and concatenate everything together. I highly recommend the deploying the use of python tutor to visualize your code. I'm hoping that holy cow is like a mind blowing experience. Mind blowing opportunity. We just saw what javascript does under the hood with some visualization. So we really didn't see it operate under the hood. 

00:55:23       No problem. So you said here on line 11, what's the usage of. Well, we're using a function and we're going to get into recursion. We have a whole like, um, block assigned to it, but I wanna I wanna let you let your weight on this. Uh, this little thing before you get to, um, to uh, to that. And so flooding is what we're doing to. This is, this is how we call our recursion, so next time that we actually, so when we get to this point where a suit w we know for a fact that this num is actually an array because we found this check because of that, we're just passing it and that becomes elements. OK, so number then becomes elements because we're calling it again. That's why we saw that python stack over and over and over again and hold onto the memory and the values of each one of those function calls. And then at the end it's like ticket and blow everything off that stack until you get to the bottom of what's actually being output, which is the of 

00:56:24       our two arrays well are ready that we're building into the, the, uh, the array that gets built by the function calls. OK? So by the time, every single time we get here, we're pushing it through something called output. And we keep concatenating those things together, but we call flattened again. Flying gets called originally with this elements and re OK. And then it gets called again if there's an array found at that index. So if the index were coming through, this index is, so each member is a four for each loop. So it's an iterative loop that's going to go and loop over our elements, right? So next time we call this flattened function, we pass up the array to it. So if it's an array, it sent back into flattened and checked again and see if the first index isn't exactly. And if it is, if the, if that index is and ruth and boom, it goes into that output. And eventually, uh, we blow off all those calls in the stack until while we're done. So let's look at this in another way. Um, let's say I have a countdown function. I want to call this countdown function. I want to count down from 10, 

00:57:40       OK, 

00:57:43       well I can actually use this. And it might actually, I hope it doesn't blow up my back and frees everything up because I'm using so much ram and, and a bandwidth with slack and the web rotc stuff designed to zoom. But this number that we pass it and originally is going to be ten the first time we pass it. All right, so if I wanted to, if I wanted to console dot log that number. 

00:58:07       Sure. 

00:58:09       Now what we could do is we could simply reverse, we could call countdown within countdown and break everything with and look at x minus one, minus one 

00:58:28       jet. 

00:58:30       So maximum cost that exceeded. 

00:58:32       OK? 

00:58:34       Ah, let's see. 

00:58:40       OK, 

00:58:45       so this means that we do not have the ability within the javascript language to actually write down this many calls. It's going to count down until you can't do it anymore. And we actually don't want to counsel that log ten and one comes along that works a little better. So this is our countdown function. We're going to print the number and then what's going to happen? Well, let's do it up here. OK, cool. So check it out. We had gone into what a lot of programmers call an infinite loop, but it's finite, not infinite. It's finite in the sense that we don't have the ability to get out of this call. Stack block. OK? So, um, this right here is recursion. We are writing a function that calls itself, and in this case we don't have a base case to stop it from happening. So what is my base case in in this recursive call? What? What's going to break me out of this loop? I need a return somewhere, right? Otherwise it's going to do everything forever, at least as far as our cost stack will allow. So I need to break out of this loop, right number is zero. So if no equal zero, we settled limitation and zero would be the last time we go for it. So now we get 10, nine, eight, seven, six, five, four, three, two, one. Once again, a function that calls itself until it doesn't. We originally invoke it with 10, so we'd give it a staircase. So when you're writing recursive functions, you can break your browser. If I did this inside of chrome, my process lets me, lets me do this because it will will terminate after x amount of calls, right? She's going to say, hey, something's wrong here, but if I tried to do this within chrome, chrome doesn't have necessarily a fail safe other than to just freeze. I'm breaking my browser. See how many iterations that allows me. This is iterative, recursive, and it's another way to write like an iterative 

01:01:09       thank you. 

01:01:12       Eventually it will just freeze up. Wow. I asked. So why? In fact, I can't even close the browser. Now in my memory, I'm about my machines, about just heat. What I can do is go to task manager and kill off. 

01:01:42       Um, 

01:01:44       kill off the process. Goes. Sorry. Chrome, you did OK. And this. Remember on career here. So let's look at this. Let's look at this with python tutor. Spring chrome back up. It just killed that tab. That's the best part about chrome. It's tabular. It's one, it's a single process per tab. So, um, you just break the tab unless you do something real bad. OK? So let's go to piping tutor again, and let's look at the Java script. So let's actually just call this with visualized in your execution. I don't know what this print drive lower right corner to resizes is, but let's just drag this altogether. This is what we're concerned with. Anyway, invoke our council's initialized countdowns. Like, nope, you gotta function. Cool. Uh, we're now going to invoke it. K first in vocation. What is known, right? So do we satisfy our base case if not equal zero at this point? No, absolutely no. Once we call. So if this is going to just bring us down to our function call and now what are we calling countdown with? Five minus one, right? So in this case was just going to just say five minutes for the number past ten minus four. So the next time we call this. So let's see what this does is going to build up our stack. So we have another call to our function with no countdown has been invoked now twice in this, in this code block. OK, let's see what happens. Are we going to satisfy this base case? No. So then we pass it with one minus four or four minus one. 

01:03:52       OK. And so now we get it with three. Are we going to satisfy this base case? Now we pass it to going to satisfy the base case. OK, pass it through our and satisfy the basis. Or sorry, at this point it's just one. So we still haven't satisfied it. And then now we pass it zero. No one is going to be zero. So we have a base case and we're going to return. Once we hit a return, we're going to walk back up the stack. What we have done here is we have created a stack and it's just like a data structure that you're going to create on your own and javascripts well with, with help. And this stack has basically it's a data structure. So think of it like an array. OK? This array took in five and it added it to the call stack. Cool. This array then took in four, so five, 

01:04:52       four, three. The arrows don't point to the right place, but imagine arrows being conscious. How about that two? One and zero. We have this many calls. Yeah. Cool. Now what if, so this is called with five was calling for, but these are all function calls themselves. OK, so this call gets, gets stored on what's called the call stack. Now at the very end of everything, it's going to actually execute this call stack in order of which everything came in and was received. OK? So that's now what's going to happen. So you're going to be able to watch this. You're going to have a witness this firsthand. Remember we've only completed nineteen to twenty six steps here with within our program. So our program has some fun things in it needs to do, it needs to blow off the call stack. OK? We're gonna call the zero call to call the three called the fort called the five and we're done. And all those all the way. It was actually a constant logging. The number that we were keeping track of Java script unraveled. Recursion unraveled brains. Spaghetti soup. 

01:06:40       Yes. So try your. So sorry. The instructions were not super duper clear. Um, but it was just saying you can use the functions that you already have written to help solve the problems. Um, do not use the built in array methods to solve these for each map filter includes, et cetera. You can use concat, pop push, whatever, but do not use the exact method that you're replicating so you can reuse that, but, but now that you're outside of the arrays file and you're working on other stuff you can use for reduced flatten is flattened. A javascript method, I don't think it is. I think that comes from like underscore or low dash or something which are javascript libraries. So you can most definitely use them from here on and hence forth. You have been deemed worthy to use. Cool. So try and push to get as much of this entire project done as possible. Um, objects we didn't really cover a lot of, but you know, if you, there's not tons, they're like, you know, keys, values, that's pretty easy. A map, objects like that for an arrays, but transform the value beach property and turn. So just look at the test and see what they're expecting. So what do we do now? Man? I'm finish this project if you can, if you're trying to get to the end of the day, the next two hours working on solution, getting all 

01:08:16       the tests to pass, you can play. You can finally play the game that you've learned enough about it. So I promise you tomorrow it's going to be a little bit easier when you get the stuff we actually have like, um, yeah, it's, it's fun. It's fun to way that we have tomorrow structured, remove duplicates was not gone over. That one is a little bit tricky. Naïve solution is not a one liner. 

01:09:09       OK. OK. 

01:09:14       OK. Any other questions? I mean we can sort of open it up to like a q and a at this point. Yeah. So what we do with, um, how the curriculum works is each week you have what we call like a sprint and each sprint is made up of a two modules. So we have a Monday, Tuesday and a Wednesday, Thursday. Um, so you've been working on the first module and Javascript for your first javascript foundation sprint. Um, you're supposed to at the end of day to day, or let's just say before you start your code challenge tomorrow morning, I want to see you submit a pull request to this, to this repository, push up all of your code that you have on your fork now and then go and open a pull request from, from that fork. And if you need help learning how to do that, we have that get through, um, pre course video that I sent out last Friday. 

01:10:12       Um, if you don't have that, just please dm me and I'll get it to you. I can put it up in Piatsa too. Um, because it's something that you can reference from forever on how to do that. You can watch that. I think it was only like twenty five minutes. Um, not everything is not necessarily do today, just by the beginning of your. So before you get to your coding exercise in the morning, it's at 8:00 AM Pacific. Submit a poll request with everything that you have so far. And in that poll requests title, just let me know your name, who you are. OK, because I don't know who Newbie wan Kenobi is on Github, a literal like student's name and I don't know who they are actually. I think I know who they are now. Um, now that I've referenced it enough, but, but yeah, I want you to come up with um, uh, come up with that poll request by the coding challenge at 8:00 AM, so 7:59 Pacific time tomorrow morning. 

01:11:01       You have to work on Javascript [inaudible] if you've already completed it, submit a pull request. Last I checked, I didn't see any poor requests come through yet, so let me see if that's changed. Yeah, I still have zero pull requests for just to prove it. So if you thought you've submitted a pull request, you haven't yet. So go ahead and submit your poll requests. Um, so that I can see your, your work and that's how you're gonna turn in each module. OK? Yes. I will definitely load this dipiazza and this one won't take super long to get up there because it will, um, it, it's only an hour and fifteen minutes or less. And so, yeah. So go ahead and submit that pr tomorrow by 7:59 Pacific and then tomorrow we start javascript to where we go into a little bit about, a little bit more about recursion, um, what it is, why we're using it, why it's important, and you have some practice problems to do a revolving around that. And if I don't, if, if I'm, if I remember correctly, tomorrow, we also cover the, this keyword and some object creation. A not full like class instantiation. But uh, yeah. So about the pull request video. I'll, I'll put that up in Piatsa. 

01:12:18       Yes. So all this whole entire entire javascript one project is, it's, I hate putting do on it, but I want to see a submission of what you've done thus far on it. K, it's not like we want all of your stuff. It's not all always feasible for every single student. That lambda school to finish every single thing that we give them that would not be in your best interest and not be in our best interests. We want to be able. Some people may actually get there and we actually can provide more support for you, um, as you continue to go along, but tomorrow, next week you're getting into some really deep concepts as well. So, uh, we want you to understand that there is no due date for the curriculum. OK? It's not like we want you to finish. However, get a little green check mark on every single test. 

01:13:09       OK? What we want you to, um, to do is, is basically have a, um, have a, uh, the best possible attempt that you can have. And then at the end of the week, on Friday mornings, we have your sprint challenge in the morning where you will be able to put into practice the things that we've taught you that week. And those are the things we want you to have known by the end of week one, two, three, four, and five, right? And those are the things that if you're kind of shaky on, we're just going to encourage you to go and continue to study k, if there is a need for provided support for help, um, we will provide that support. We have a way to intervene and make sure that you are in this progressive like loop of learning, right, because if you're just getting too far behind and overwhelmed and swamped, um, th, th, there's a big difference there if you're completely outside that edge work zone, right? 

01:14:04       So I just want to, I want to emphasize that. So submit a pull request with what you have completed by the beginning of the day on, on Wednesday, and then we'll, we'll move on from there. Should we create a new branch or just push that up? So push all of your commits to your fork and then open up a poll request from the fork. So you should have forks the repository and cloned that fork and you should be pushing all of your commits to that, to that fork, right? For struggling on problems. Should we include our attempt and notes? That would be. That would be absolutely fantastic. If you're struggling on a problem and you're like, just just give us everything you have to that point and be like, Hey, this is what I've done. This is what I've attempted. So when we get the all of the TA support, we can take you in and we can say, hey, this is how I would have solved that problem in the future we're going to be able to have like full solution review code, like code reviews with all, with, with groups. OK. And then we're going to be able to walk through all of that stuff. I'm going to provide you with as many solutions to the problems is I can just so you have a working copy of the mall as many. So. OK. So remember, yes. Objects, callbacks, closures, array. These four files are a part of this project and we want you to push this project up. So I'm just going to show you how I would do that so far. So I am on. Please tell me this is not just that. It's an actual clone. 

01:15:50       Yeah. Cool. OK. So I'm going to actually just do this process for you right now. OK? So look at all my modifications and changes that I've made to the, to the, um, project. But I'm going to go in and I'm going to revert my change is to that test file. So ignore what I just did there with this gooey, because we want you to actually use the command line, not gooey, OK? What does it give a graphical user interface. So now I can do it, get status, and I'm going to get rid of those tests in order to. This isn't happening. There is a command line. It's better. It's better for you. Do as I say, not as I do my principal here. So have these changes are going to get status. I can see my changes. OK, I'm going to do a get add to stage my changes. 

01:16:41       Awesome. So remember I ran a remote to see what my remote origin is pointing to. Origin is pointing to my fork of this repository. If this right here, your origin is pointing to lambda school, it's, it's not your, you have a master copy of the repository. This is not a fork. OK? So you want to make sure that it's pointing to your get hub username. OK? So now, and that's where you running? Get Remote v OK, so now what I want to do is I want to say get commit my college. Try get it. It's kind of funny. OK, get statusK. , all of my, all of my changes have been staged and now committed. So I'm going to push my changes to my fork. 

01:17:36       Get push origin master pushes them to my origin. And if I run that getting remote Dash v, my origin is what it's pointing to my fork right now. I can come over here into get hub and I can say javascript one and I can go and I can look at what's funny is I have my fork and everything so I can look at this tab called poll requests. All right, so I am noticing there's no poll requests. So I have this flat honest. This is open. So I can open up a poll request. And if you look, uh, I know what the problem is, a compare across works. So this is the part that you really want to pay attention to. OK? So instead of using the branch branching technique, which we're going to teach you when you get to your project phase, instead of using the branch and technique, we're going to compare problems across forks and look, I can see all of the forks that have taken place since we opened up this project and there is mine. 

01:18:41       So look at this. I am comparing the base fork of lambda schools master fork and I'm also comparing the head fort, which is Ryan Hca, a javascript [inaudible]. That's my forte. So I can actually open up this pull request and I can say Ryan Hamblin Amboy, um, poll request and look what this poor requests. I'm going to get some commits. So I've done an example of this with the previous students so you can see some previous commits, an act done, but there's my college trial which is my final commit for this entire thing. So now that I have Ryan have on pull requests, I as an instructor, I'm going to come in and I'm going to be able to look at your code side by side what was originally there. And then what the student actually put in there, by the way, deleting comments and calming down stuff, highly recommended. 

01:19:33       It helps me in my eyes. OK. So now I can go and see everything that I did. Oh, I didn't get a solution for. Oh, and I have a bunch of comments because all my comments out code is all here on my home. I stuff's here. In fact I should have come out, but it doesn't look like I quite got everything because I know find is in here. Um, so if I look at this file here side by side and I to look at all of them, um, you know, I know, I know for a fact that this student Ryan didn't get fined and then that other filter, which is fine, but what I'm going to do as an instructor is going to say, Hey, I noticed that you didn't quite get to the solution for filter and find. And I'm going to give you, I'm going to give you comments and suggestions there. 

01:20:25       If there is anything wrong with your code, which I'm using some sort of special format or that makes my code super beautiful so I'm never going to have any problems, right? Uh, but if there was a missing semi-colon here, I'm going to leave something like missing semi-colon and I'm gonna leave you comments and review your code this way. Now this is, this process is going to get a lot more fluid, a lot more dialed in as we continue, but this doesn't, it doesn't scale well if you can understand most of the correction is going to come on the sprint reviews on Fridays, but when we can get here we can get to this point where we can actually have somebody coming in and doing all of this and like showing in Silica. I know that this student here, Ryan only had a couple of attempts on, on this file, right? So I would talk about it with them and reach out. But this, oh this is lovely. Like lovely code here. Limited function count. Everything looks lovely. Um, OK. So that's how you would open up that poll request. If I got a javascript one now I can look and I can see how many posts are open and there's just this one now. I don't want to muddy the waters here because the poor requests are for you guys, not for me. So I'm just gonna close it. 

01:21:35       Awesome. Did you have any questions about that? And I can, I can link up that get video just for you, uh, for, uh, for anybody who wants a refresher on it, which is what I'm going to do right now. So I'm going to leave you to just run as fast as you can at full speed up until you hit your pillow tonight and fall asleep and dream about four loops. By the way, are any of you have, it's kind of early to ask this question, but our interview having like coding dreams yet, like when you have a solution? Yeah, there you go. You know, crafting a solution in that light, which I call it the witching hour when I wake up at like 5:00 AM and my mind is just like, oh, I have this, I have this. And then I go and sit at my computer and like I lost it. I can't do this. But yeah, asleep. It's possible that I see like syntax and Javascript, I am not sure. Probably pipe in some sort of compiler and allow you to do it. 

01:22:32       Oh, you mean something like changing? Yes, that is possible. Uh, the whole value promise with a type that. So that type is a promise and that promise receiving. Right. So that doesn't exist unless you use a super set like typescript or flow script but returning the chain. Oh yeah. That is all javascript right there. But like adding a type know you can set default parameters to your functions. But typing only comes a buddy's could've mind did this, about typescript. Did he have what? It'd be interesting to see. Yeah, a dme Alexander, once he figured out how he was able to achieve this, because I'm assuming there's some sort of trance pilar there that takes that version of javascript that he's using. Yeah, it's flow type. I, I'm not familiar with the syntax beyond typescript or whatever. So. OK, yeah. Getting linting nightmare errors or error nightmares. Nice, cool. 

01:23:57       OK, I, you know, those, those coding dreams are, you're definitely all out in the deep end and there's like some sharks swimming around, but they're not man-eating sharks. OK? We've left you in a pool of Nice sharks. All right? Um, just to give you that enough anxiety to see it, to sink or swim and I guarantee you I'm the only thing that's going to get in your way to becoming a software developer is I'm giving up. You can do this. We give you all the support you need and it's in our best interest for you to succeed. I've worked for five different software companies now in my short, you know, four years of learning how to code so don't have a giant show track record at sticking around for more than a year and a company, um, and a lambda school is by far the only company that I've worked for whose incentives line up exactly what their constituents and by constituents. That's you. So you, our product and our product is, it's, it really is. We do not succeed unless you do. So we're only gonna make you succeed. We're going to push you as much as we feel like we need to. And then eventually one day you're gonna wake up and you're going to say, I can freaking write software. And it's amazing. I am a software developer. I'm, I'm developed developing websites and web applications and it's, it's an amazing feeling. 

01:25:28       Oh yeah. I'll be here. So what's funny is by the time you guys finish OK, so by the time [inaudible] finish, it will be like my, it'll be my year mark. So I started just a week before cs six start [inaudible] started was that they was just me, Ben and Austin. And now like we have multiple stand up meetings with multiple instructor teams and multiple, ah, multiple fund stuff. It's pretty cool. Ah, it is not. So disregard this syllabus for now as far as. Well, OK. So how it's going to change in the future? I don't have, I have a living document that like, I don't want to expose to you yet because things could get really, really different. OK. But what I can, what I can give you is sort of the week one is javascript fundamentals. Um, we [inaudible] we are, uh, we, we do data structures and algorithms. 

01:26:33       Week three, you get exposure to front end development, html, css, some dominant mutation with Java script and then we move you into react for like four and a half weeks. You do react and reducts and you do more reducts and then you learn node, Mongo, and then my sequel, and then you learn about, there's a testing sprint that we're, that we're testing module that we're, um, you know, so some of it we're trying to decide new stuff to teach you is what I'm saying. So when I say there is a living document of the new syllabus, look for that at the beginning of the year because it's on me to get that out by the beginning of the year. Yeah. So slack, slack Bot will respond to a couple of commands. You can program that in slackbots. Um, so you can write things like brown bags, tie somebody, type in brown bags, just the forward. 

01:27:33       There you go. List of all the brown bag lectures that have come from outsiders. OK. So the question was how, how do, how we use data structures and our logo in the front end Java script is a programming language and it's not just for front end development anymore, it's not just for the web browser and you can use it like a programming language and you can build out data structures with it. You've already done that today. You've built out some arrays and some objects and things functions. So next week we get into actually using objects in tax class syntax to create data structures like, um, you know, some, some very common ones that you'll see on the industry. Hash tables. I'm linked lists. Um, we go through stacks and queues. We go through trees, binary search trees, heaps, um, and graphs. So we teach you all of that and how to do it, how to implement those in Javascript is a really, really cool o'reilly book that I highly recommend if you're interested. It's called or o'reilly, this one. Yeah. 

01:29:01       Yeah. 

01:29:06       I'm from Salt Lake City. 

01:29:13       Yeah. 

01:29:17       This book really made a difference in my life as far as learning these things in javascript was really fun. Um, it's written in like strictly [inaudible] and it uses like a prototypal inheritance. Um, but yeah. Which commercials? I'm seriously, I'm familiar by the way. I don't need to be recording all this.